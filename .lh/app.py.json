{
    "sourceFile": "app.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 16,
            "patches": [
                {
                    "date": 1701866007123,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1701866021301,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -238,9 +238,9 @@\n     return render_template('chat.html')\r\n \r\n @app.route('/process')\r\n def process():\r\n-    user_input = request.form['userInput']\r\n+    user_input = 'product max price 500'\r\n     response = analyze_input(user_input, df)  # Use the analyze_input function from your script\r\n     return jsonify({'response': response})\r\n \r\n if __name__ == '__main__':\r\n"
                },
                {
                    "date": 1701866026923,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -238,9 +238,9 @@\n     return render_template('chat.html')\r\n \r\n @app.route('/process')\r\n def process():\r\n-    user_input = 'product max price 500'\r\n+    user_input = 'product max price 500';\r\n     response = analyze_input(user_input, df)  # Use the analyze_input function from your script\r\n     return jsonify({'response': response})\r\n \r\n if __name__ == '__main__':\r\n"
                },
                {
                    "date": 1701866058450,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -236,8 +236,12 @@\n @app.route('/')\r\n def index():\r\n     return render_template('chat.html')\r\n \r\n+@app.route('/test')\r\n+def test():\r\n+    return 'test';\r\n+\r\n @app.route('/process')\r\n def process():\r\n     user_input = 'product max price 500';\r\n     response = analyze_input(user_input, df)  # Use the analyze_input function from your script\r\n"
                },
                {
                    "date": 1701866065698,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -238,9 +238,9 @@\n     return render_template('chat.html')\r\n \r\n @app.route('/test')\r\n def test():\r\n-    return 'test';\r\n+    return 'test'\r\n \r\n @app.route('/process')\r\n def process():\r\n     user_input = 'product max price 500';\r\n"
                },
                {
                    "date": 1701866082711,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -236,11 +236,11 @@\n @app.route('/')\r\n def index():\r\n     return render_template('chat.html')\r\n \r\n-@app.route('/test')\r\n-def test():\r\n-    return 'test'\r\n+@app.route('/hello')\r\n+def hello():\r\n+    return 'Hello, World'\r\n \r\n @app.route('/process')\r\n def process():\r\n     user_input = 'product max price 500';\r\n"
                },
                {
                    "date": 1701866114361,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -236,15 +236,11 @@\n @app.route('/')\r\n def index():\r\n     return render_template('chat.html')\r\n \r\n-@app.route('/hello')\r\n-def hello():\r\n-    return 'Hello, World'\r\n-\r\n-@app.route('/process')\r\n+@app.route('/process', methods=['POST'])\r\n def process():\r\n-    user_input = 'product max price 500';\r\n+    user_input = request.form['userInput']\r\n     response = analyze_input(user_input, df)  # Use the analyze_input function from your script\r\n     return jsonify({'response': response})\r\n \r\n if __name__ == '__main__':\r\n"
                },
                {
                    "date": 1701866165877,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,251 @@\n+from flask import Flask, render_template, request, jsonify\r\n+import pandas as pd\r\n+import nltk\r\n+from nltk.tokenize import word_tokenize\r\n+from nltk.corpus import stopwords\r\n+from nltk.stem import PorterStemmer\r\n+from nltk.stem import WordNetLemmatizer\r\n+\r\n+# Initialize Flask app\r\n+app = Flask(__name__)\r\n+\r\n+# Load your DataFrame here\r\n+# Example: df = pd.read_csv(\"your_data_file.csv\")\r\n+df = pd.read_csv('SET_DATA.csv')  # Replace with your actual data file\r\n+products = df\r\n+\r\n+# Initialize NLTK tools (Ensure you have downloaded the necessary NLTK datasets)\r\n+stop_words = set(stopwords.words('english'))\r\n+porter = PorterStemmer()\r\n+lemmatizer = WordNetLemmatizer()\r\n+# Function \r\n+# Function to find the product with the highest price\r\n+def product_with_highest_price(df):\r\n+    highest_price = df['Price'].max()\r\n+    highest_price_product = df[df['Price'] == highest_price]['Product Title'].values[0]\r\n+    return highest_price_product,highest_price\r\n+\r\n+# Function to find the product with the lowest price\r\n+def product_with_lowest_price(df):\r\n+    lowest_price = df['Price'].min()\r\n+    lowest_price_product = df[df['Price'] == lowest_price]['Product Title'].values[0]\r\n+    return lowest_price_product,lowest_price\r\n+\r\n+# Function to calculate the average price of products\r\n+def average_product_price(df):\r\n+    average_price = df['Price'].mean()\r\n+    return average_price\r\n+\r\n+# Function to find the product with the lowest rating\r\n+def product_with_lowest_rating(df):\r\n+    lowest_Rating = df['Rating'].min()\r\n+    lowest_Rating_product = df[df['Rating'] == lowest_Rating]['Product Title'].values[0]\r\n+    return lowest_Rating_product,lowest_Rating\r\n+\r\n+# Function to find the product with the highest rating\r\n+def product_with_highest_rating(df):\r\n+    highest_Rating = df['Rating'].max()\r\n+    highest_Rating_product = df[df['Rating'] == highest_Rating]['Product Title'].values[0]\r\n+    return highest_Rating_product,highest_Rating\r\n+\r\n+\r\n+\r\n+def best_phones_above_price(df, min_price):\r\n+    high_priced_phones = df[df['Price'] >= min_price]\r\n+    highest_rated_phones = high_priced_phones[high_priced_phones['Rating'] == high_priced_phones['Rating'].max()]\r\n+    recommended_phones = highest_rated_phones[['Product Title', 'Price']].copy()\r\n+    return recommended_phones\r\n+\r\n+def best_phones_under_price(df, max_price):\r\n+    affordable_phones = df[df['Price'] <= max_price]\r\n+    highest_rated_phones = affordable_phones[affordable_phones['Rating'] == affordable_phones['Rating'].max()]\r\n+    recommended_phones = highest_rated_phones[['Product Title', 'Price']].copy()\r\n+    return recommended_phones\r\n+ \r\n+\r\n+def products_with_free_shipping(df):\r\n+    free_shipping_df = df[df['Free Shipping Status'] == True]\r\n+    free_shipping_products = free_shipping_df['Product Title'].tolist()\r\n+    return free_shipping_products\r\n+\r\n+def products_in_daraz_mall(df):\r\n+    daraz_mall_df = df[df['Daraz Mall Status'] == True]\r\n+    daraz_mall_products = daraz_mall_df['Product Title'].tolist()\r\n+    return daraz_mall_products\r\n+\r\n+def sellers_with_best_rating(df):\r\n+    best_seller_rating = df['Seller Rating'].max()\r\n+    best_sellers = df[df['Seller Rating'] == best_seller_rating]['Product Title'].tolist()\r\n+    return best_sellers\r\n+\r\n+def sellers_who_ship_on_time(df):\r\n+    on_time_shippers = df[df['Ship on Time Score'] >= 90]  # Assuming the score is out of 100\r\n+    on_time_shipping_products = on_time_shippers['Product Title'].tolist()\r\n+    return on_time_shipping_products\r\n+\r\n+def get_product_specifications(df, product_title):\r\n+    product_specs = df[df['Product Title'].str.contains(product_title, case=False)]\r\n+    if not product_specs.empty:\r\n+        return product_specs.iloc[0]['Specifications']\r\n+    else:\r\n+        return \"Product not found.\"\r\n+\r\n+def find_phone_with_feature(df, feature):\r\n+    phones_with_feature = df[df['Specifications'].str.contains(feature, case=False)]\r\n+    products = phones_with_feature['Product Title'].tolist()\r\n+    return products\r\n+# +++++++++++++++++++++++++++++\r\n+\r\n+def product_with_most_questions(df):\r\n+    most_questions = df['No.of Questions'].max()\r\n+    most_questions_product = df[df['No.of Questions'] == most_questions]['Product Title'].values[0]\r\n+    return most_questions_product, most_questions\r\n+\r\n+def brand_of_best_selling(df):\r\n+    # Filter the products with the highest price first\r\n+    highest_price = df['Price'].max()\r\n+    highest_price_products = df[df['Price'] == highest_price]\r\n+    highest_rated = highest_price_products['Rating'].max()\r\n+    best_selling_product = highest_price_products[highest_price_products['Rating'] == highest_rated]\r\n+    best_selling_brand = best_selling_product['Brand'].values[0]\r\n+    return best_selling_brand, (highest_price, highest_rated)\r\n+\r\n+def brand_of_highest_price_mobile(df):\r\n+    highest_price = df['Price'].max()\r\n+    highest_price_brand = df[df['Price'] == highest_price]['Brand'].values[0]\r\n+    return highest_price_brand, highest_price\r\n+\r\n+def brand_of_lowest_price_mobile(df):\r\n+    lowest_price = df['Price'].min()\r\n+    lowest_price_brand = df[df['Price'] == lowest_price]['Brand'].values[0]\r\n+    return lowest_price_brand, lowest_price\r\n+\r\n+##\r\n+# Sample data in the form of a DataFrame with product information\r\n+# Replace this with the actual DataFrame you are using\r\n+\r\n+# Define your functions here (e.g., product_with_highest_price, product_with_lowest_price, etc.)\r\n+\r\n+bot_responses = {\r\n+    \"hi\": [\"Hi there!\", \"Hello!\"],\r\n+    \"hello\": [\"Hi there!\", \"Hello!\"],\r\n+    \"how are you\": [\"I'm good, thanks for asking.\", \"I'm doing well, thank you!\"],\r\n+    \"what's up\": [\"Not much, just here to help.\", \"I'm here to assist you!\"],\r\n+    \"goodbye\": [\"Goodbye!\", \"See you later!\", \"Bye!\"],\r\n+    \"thanks\": [\"myPleasure!\", \":}\", \":} :}\"],\r\n+}\r\n+\r\n+# Function to generate a random bot response\r\n+def get_bot_response(user_input):\r\n+    if user_input.lower() in bot_responses:\r\n+        return random.choice(bot_responses[user_input.lower()])\r\n+    else:\r\n+        return \"Sorry, I don't understand that.\"\r\n+\r\n+# Updated analyze_input function\r\n+def analyze_input(user_input, df):\r\n+    tokens = word_tokenize(user_input.lower())\r\n+    filtered_tokens = [word for word in tokens if word not in stop_words]\r\n+    stemmed_tokens = [porter.stem(word) for word in filtered_tokens]\r\n+    lemmatized_tokens = [lemmatizer.lemmatize(word) for word in stemmed_tokens]\r\n+    pos_tags = nltk.pos_tag(lemmatized_tokens)\r\n+    matching_columns = {token: column for token in lemmatized_tokens for column in df.columns if token in column.lower()}\r\n+\r\n+\r\n+#     # Example for 'price' related queries\r\n+ # Logic for 'price' related queries\r\n+    if 'price' in matching_columns or 'price' in user_input:\r\n+        if 'max' in lemmatized_tokens or 'highest' in lemmatized_tokens or 'max' in user_input or 'highest' in user_input:\r\n+            return product_with_highest_price(df)\r\n+        elif 'min' in lemmatized_tokens or 'lowest' in lemmatized_tokens or 'minimum' in user_input or 'lowest' in user_input:\r\n+            return product_with_lowest_price(df)\r\n+        elif 'averag' in lemmatized_tokens or 'average' in user_input:\r\n+            return average_product_price(df)\r\n+\r\n+    # Logic for 'rating' related queries\r\n+    if 'rating' in matching_columns or 'rating' in user_input:\r\n+        if 'max' in lemmatized_tokens or 'highest' in lemmatized_tokens or 'max' in user_input or 'highest' in user_input:\r\n+            return product_with_highest_rating(df)\r\n+        elif 'min' in lemmatized_tokens or 'lowest' in lemmatized_tokens or 'minimum' in user_input or 'lowest' in user_input:\r\n+            return product_with_lowest_rating(df)\r\n+\r\n+    # Logic for 'shipping' related queries\r\n+    if 'ship' in lemmatized_tokens or 'shipping' in matching_columns or 'ship' in user_input or 'shipping' in user_input:\r\n+        if 'free' in lemmatized_tokens or 'free' in user_input:\r\n+            return products_with_free_shipping(df)\r\n+        elif 'time' in lemmatized_tokens or 'time' in user_input:\r\n+            return sellers_who_ship_on_time(df)\r\n+\r\n+    # Logic for 'Daraz Mall' related queries\r\n+    if 'daraz' in lemmatized_tokens and 'mall' in lemmatized_tokens or 'daraz' in user_input and 'mall' in user_input:\r\n+        return products_in_daraz_mall(df)\r\n+\r\n+    # Logic for 'seller' related queries\r\n+    if 'seller' in matching_columns or 'seller' in user_input:\r\n+        if 'best' in lemmatized_tokens or 'top' in lemmatized_tokens or 'best' in user_input or 'top' in user_input:\r\n+            return sellers_with_best_rating(df)\r\n+\r\n+    # Logic for queries related to specific features or specifications\r\n+    if 'feature' in lemmatized_tokens or 'specification' in matching_columns or 'feature' in user_input or 'specification' in user_input:\r\n+        feature = \" \".join(tokens[tokens.index('with') + 1:]) if 'with' in tokens else \"\"\r\n+        return find_phone_with_feature(df, feature)\r\n+\r\n+    # Logic for finding best phones under a certain price\r\n+  # if 'best' in lemmatized_tokens and 'phone' in lemmatized_tokens or 'under' in lemmatized_tokens or 'best' in user_input and 'phone' in user_input or 'under' in user_input:\r\n+    if 'best' in lemmatized_tokens and 'phone' in lemmatized_tokens or 'under' in lemmatized_tokens or 'best' in user_input and 'phone' in user_input or 'under' in user_input:\r\n+        try:\r\n+            max_price = [int(t) for t in tokens if t.isdigit()]\r\n+            if max_price:\r\n+                return best_phones_under_price(df, max_price[0])  # Assuming you only need the first number found\r\n+            else:\r\n+                return \"Please provide a valid price limit.\"\r\n+        except ValueError:\r\n+            return \"Please provide a valid price limit.\"\r\n+\r\n+ ##0000000000000000000000\r\n+    if 'phone' in lemmatized_tokens and 'above' in lemmatized_tokens or 'greater' in lemmatized_tokens or 'phone' in user_input and 'above' in user_input or 'above' in user_input:\r\n+          try:\r\n+              max_price = [int(t) for t in tokens if t.isdigit()]\r\n+              if max_price:\r\n+                  return best_phones_above_price(df, max_price[0])  # Assuming you only need the first number found\r\n+              else:\r\n+                  return \"Please provide a valid price limit.\"\r\n+          except ValueError:\r\n+              return \"Please provide a valid price limit.\"\r\n+\r\n+\r\n+   # Logic for queries about the product with most questions++++++++\r\n+    if 'most' in lemmatized_tokens and 'question' in lemmatized_tokens or 'most' in user_input and 'question' in user_input:\r\n+        return product_with_most_questions(df)\r\n+\r\n+    # Logic for queries about the best selling brand\r\n+    if 'best' in lemmatized_tokens and 'selling' in lemmatized_tokens and 'brand' in lemmatized_tokens or 'best' in user_input and 'selling' in user_input and 'brand' in user_input:\r\n+        return brand_of_best_selling(df)\r\n+\r\n+    # Logic for queries about the brand of the highest price mobile\r\n+    if 'highest' in lemmatized_tokens and 'price' in lemmatized_tokens and 'brand' in lemmatized_tokens or  'highest' in user_input and 'price' in user_input and 'brand' in user_input:\r\n+        return brand_of_highest_price_mobile(df)\r\n+\r\n+    # Logic for queries about the brand of the lowest price mobile\r\n+    if 'lowest' in lemmatized_tokens and 'price' in lemmatized_tokens and 'brand' in lemmatized_tokens or  'lowest' in user_input and 'price' in user_input and 'brand' in user_input:\r\n+        return brand_of_lowest_price_mobile(df)\r\n+    else:\r\n+        return get_bot_response(user_input)\r\n+\r\n+\r\n+@app.route('/')\r\n+def index():\r\n+    return 'Hello, World'\r\n+\r\n+@app.route('/hello')\r\n+def hello():\r\n+    return 'Hello, World'\r\n+\r\n+@app.route('/process', methods=['POST'])\r\n+def process():\r\n+    user_input = request.form['userInput']\r\n+    response = analyze_input(user_input, df)  # Use the analyze_input function from your script\r\n+    return jsonify({'response': response})\r\n+\r\n+if __name__ == '__main__':\r\n+    app.run(debug=True)\r\n"
                },
                {
                    "date": 1701866175219,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -248,251 +248,4 @@\n     return jsonify({'response': response})\r\n \r\n if __name__ == '__main__':\r\n     app.run(debug=True)\r\n-from flask import Flask, render_template, request, jsonify\r\n-import pandas as pd\r\n-import nltk\r\n-from nltk.tokenize import word_tokenize\r\n-from nltk.corpus import stopwords\r\n-from nltk.stem import PorterStemmer\r\n-from nltk.stem import WordNetLemmatizer\r\n-\r\n-# Initialize Flask app\r\n-app = Flask(__name__)\r\n-\r\n-# Load your DataFrame here\r\n-# Example: df = pd.read_csv(\"your_data_file.csv\")\r\n-df = pd.read_csv('SET_DATA.csv')  # Replace with your actual data file\r\n-products = df\r\n-\r\n-# Initialize NLTK tools (Ensure you have downloaded the necessary NLTK datasets)\r\n-stop_words = set(stopwords.words('english'))\r\n-porter = PorterStemmer()\r\n-lemmatizer = WordNetLemmatizer()\r\n-# Function \r\n-# Function to find the product with the highest price\r\n-def product_with_highest_price(df):\r\n-    highest_price = df['Price'].max()\r\n-    highest_price_product = df[df['Price'] == highest_price]['Product Title'].values[0]\r\n-    return highest_price_product,highest_price\r\n-\r\n-# Function to find the product with the lowest price\r\n-def product_with_lowest_price(df):\r\n-    lowest_price = df['Price'].min()\r\n-    lowest_price_product = df[df['Price'] == lowest_price]['Product Title'].values[0]\r\n-    return lowest_price_product,lowest_price\r\n-\r\n-# Function to calculate the average price of products\r\n-def average_product_price(df):\r\n-    average_price = df['Price'].mean()\r\n-    return average_price\r\n-\r\n-# Function to find the product with the lowest rating\r\n-def product_with_lowest_rating(df):\r\n-    lowest_Rating = df['Rating'].min()\r\n-    lowest_Rating_product = df[df['Rating'] == lowest_Rating]['Product Title'].values[0]\r\n-    return lowest_Rating_product,lowest_Rating\r\n-\r\n-# Function to find the product with the highest rating\r\n-def product_with_highest_rating(df):\r\n-    highest_Rating = df['Rating'].max()\r\n-    highest_Rating_product = df[df['Rating'] == highest_Rating]['Product Title'].values[0]\r\n-    return highest_Rating_product,highest_Rating\r\n-\r\n-\r\n-\r\n-def best_phones_above_price(df, min_price):\r\n-    high_priced_phones = df[df['Price'] >= min_price]\r\n-    highest_rated_phones = high_priced_phones[high_priced_phones['Rating'] == high_priced_phones['Rating'].max()]\r\n-    recommended_phones = highest_rated_phones[['Product Title', 'Price']].copy()\r\n-    return recommended_phones\r\n-\r\n-def best_phones_under_price(df, max_price):\r\n-    affordable_phones = df[df['Price'] <= max_price]\r\n-    highest_rated_phones = affordable_phones[affordable_phones['Rating'] == affordable_phones['Rating'].max()]\r\n-    recommended_phones = highest_rated_phones[['Product Title', 'Price']].copy()\r\n-    return recommended_phones\r\n- \r\n-\r\n-def products_with_free_shipping(df):\r\n-    free_shipping_df = df[df['Free Shipping Status'] == True]\r\n-    free_shipping_products = free_shipping_df['Product Title'].tolist()\r\n-    return free_shipping_products\r\n-\r\n-def products_in_daraz_mall(df):\r\n-    daraz_mall_df = df[df['Daraz Mall Status'] == True]\r\n-    daraz_mall_products = daraz_mall_df['Product Title'].tolist()\r\n-    return daraz_mall_products\r\n-\r\n-def sellers_with_best_rating(df):\r\n-    best_seller_rating = df['Seller Rating'].max()\r\n-    best_sellers = df[df['Seller Rating'] == best_seller_rating]['Product Title'].tolist()\r\n-    return best_sellers\r\n-\r\n-def sellers_who_ship_on_time(df):\r\n-    on_time_shippers = df[df['Ship on Time Score'] >= 90]  # Assuming the score is out of 100\r\n-    on_time_shipping_products = on_time_shippers['Product Title'].tolist()\r\n-    return on_time_shipping_products\r\n-\r\n-def get_product_specifications(df, product_title):\r\n-    product_specs = df[df['Product Title'].str.contains(product_title, case=False)]\r\n-    if not product_specs.empty:\r\n-        return product_specs.iloc[0]['Specifications']\r\n-    else:\r\n-        return \"Product not found.\"\r\n-\r\n-def find_phone_with_feature(df, feature):\r\n-    phones_with_feature = df[df['Specifications'].str.contains(feature, case=False)]\r\n-    products = phones_with_feature['Product Title'].tolist()\r\n-    return products\r\n-# +++++++++++++++++++++++++++++\r\n-\r\n-def product_with_most_questions(df):\r\n-    most_questions = df['No.of Questions'].max()\r\n-    most_questions_product = df[df['No.of Questions'] == most_questions]['Product Title'].values[0]\r\n-    return most_questions_product, most_questions\r\n-\r\n-def brand_of_best_selling(df):\r\n-    # Filter the products with the highest price first\r\n-    highest_price = df['Price'].max()\r\n-    highest_price_products = df[df['Price'] == highest_price]\r\n-    highest_rated = highest_price_products['Rating'].max()\r\n-    best_selling_product = highest_price_products[highest_price_products['Rating'] == highest_rated]\r\n-    best_selling_brand = best_selling_product['Brand'].values[0]\r\n-    return best_selling_brand, (highest_price, highest_rated)\r\n-\r\n-def brand_of_highest_price_mobile(df):\r\n-    highest_price = df['Price'].max()\r\n-    highest_price_brand = df[df['Price'] == highest_price]['Brand'].values[0]\r\n-    return highest_price_brand, highest_price\r\n-\r\n-def brand_of_lowest_price_mobile(df):\r\n-    lowest_price = df['Price'].min()\r\n-    lowest_price_brand = df[df['Price'] == lowest_price]['Brand'].values[0]\r\n-    return lowest_price_brand, lowest_price\r\n-\r\n-##\r\n-# Sample data in the form of a DataFrame with product information\r\n-# Replace this with the actual DataFrame you are using\r\n-\r\n-# Define your functions here (e.g., product_with_highest_price, product_with_lowest_price, etc.)\r\n-\r\n-bot_responses = {\r\n-    \"hi\": [\"Hi there!\", \"Hello!\"],\r\n-    \"hello\": [\"Hi there!\", \"Hello!\"],\r\n-    \"how are you\": [\"I'm good, thanks for asking.\", \"I'm doing well, thank you!\"],\r\n-    \"what's up\": [\"Not much, just here to help.\", \"I'm here to assist you!\"],\r\n-    \"goodbye\": [\"Goodbye!\", \"See you later!\", \"Bye!\"],\r\n-    \"thanks\": [\"myPleasure!\", \":}\", \":} :}\"],\r\n-}\r\n-\r\n-# Function to generate a random bot response\r\n-def get_bot_response(user_input):\r\n-    if user_input.lower() in bot_responses:\r\n-        return random.choice(bot_responses[user_input.lower()])\r\n-    else:\r\n-        return \"Sorry, I don't understand that.\"\r\n-\r\n-# Updated analyze_input function\r\n-def analyze_input(user_input, df):\r\n-    tokens = word_tokenize(user_input.lower())\r\n-    filtered_tokens = [word for word in tokens if word not in stop_words]\r\n-    stemmed_tokens = [porter.stem(word) for word in filtered_tokens]\r\n-    lemmatized_tokens = [lemmatizer.lemmatize(word) for word in stemmed_tokens]\r\n-    pos_tags = nltk.pos_tag(lemmatized_tokens)\r\n-    matching_columns = {token: column for token in lemmatized_tokens for column in df.columns if token in column.lower()}\r\n-\r\n-\r\n-#     # Example for 'price' related queries\r\n- # Logic for 'price' related queries\r\n-    if 'price' in matching_columns or 'price' in user_input:\r\n-        if 'max' in lemmatized_tokens or 'highest' in lemmatized_tokens or 'max' in user_input or 'highest' in user_input:\r\n-            return product_with_highest_price(df)\r\n-        elif 'min' in lemmatized_tokens or 'lowest' in lemmatized_tokens or 'minimum' in user_input or 'lowest' in user_input:\r\n-            return product_with_lowest_price(df)\r\n-        elif 'averag' in lemmatized_tokens or 'average' in user_input:\r\n-            return average_product_price(df)\r\n-\r\n-    # Logic for 'rating' related queries\r\n-    if 'rating' in matching_columns or 'rating' in user_input:\r\n-        if 'max' in lemmatized_tokens or 'highest' in lemmatized_tokens or 'max' in user_input or 'highest' in user_input:\r\n-            return product_with_highest_rating(df)\r\n-        elif 'min' in lemmatized_tokens or 'lowest' in lemmatized_tokens or 'minimum' in user_input or 'lowest' in user_input:\r\n-            return product_with_lowest_rating(df)\r\n-\r\n-    # Logic for 'shipping' related queries\r\n-    if 'ship' in lemmatized_tokens or 'shipping' in matching_columns or 'ship' in user_input or 'shipping' in user_input:\r\n-        if 'free' in lemmatized_tokens or 'free' in user_input:\r\n-            return products_with_free_shipping(df)\r\n-        elif 'time' in lemmatized_tokens or 'time' in user_input:\r\n-            return sellers_who_ship_on_time(df)\r\n-\r\n-    # Logic for 'Daraz Mall' related queries\r\n-    if 'daraz' in lemmatized_tokens and 'mall' in lemmatized_tokens or 'daraz' in user_input and 'mall' in user_input:\r\n-        return products_in_daraz_mall(df)\r\n-\r\n-    # Logic for 'seller' related queries\r\n-    if 'seller' in matching_columns or 'seller' in user_input:\r\n-        if 'best' in lemmatized_tokens or 'top' in lemmatized_tokens or 'best' in user_input or 'top' in user_input:\r\n-            return sellers_with_best_rating(df)\r\n-\r\n-    # Logic for queries related to specific features or specifications\r\n-    if 'feature' in lemmatized_tokens or 'specification' in matching_columns or 'feature' in user_input or 'specification' in user_input:\r\n-        feature = \" \".join(tokens[tokens.index('with') + 1:]) if 'with' in tokens else \"\"\r\n-        return find_phone_with_feature(df, feature)\r\n-\r\n-    # Logic for finding best phones under a certain price\r\n-  # if 'best' in lemmatized_tokens and 'phone' in lemmatized_tokens or 'under' in lemmatized_tokens or 'best' in user_input and 'phone' in user_input or 'under' in user_input:\r\n-    if 'best' in lemmatized_tokens and 'phone' in lemmatized_tokens or 'under' in lemmatized_tokens or 'best' in user_input and 'phone' in user_input or 'under' in user_input:\r\n-        try:\r\n-            max_price = [int(t) for t in tokens if t.isdigit()]\r\n-            if max_price:\r\n-                return best_phones_under_price(df, max_price[0])  # Assuming you only need the first number found\r\n-            else:\r\n-                return \"Please provide a valid price limit.\"\r\n-        except ValueError:\r\n-            return \"Please provide a valid price limit.\"\r\n-\r\n- ##0000000000000000000000\r\n-    if 'phone' in lemmatized_tokens and 'above' in lemmatized_tokens or 'greater' in lemmatized_tokens or 'phone' in user_input and 'above' in user_input or 'above' in user_input:\r\n-          try:\r\n-              max_price = [int(t) for t in tokens if t.isdigit()]\r\n-              if max_price:\r\n-                  return best_phones_above_price(df, max_price[0])  # Assuming you only need the first number found\r\n-              else:\r\n-                  return \"Please provide a valid price limit.\"\r\n-          except ValueError:\r\n-              return \"Please provide a valid price limit.\"\r\n-\r\n-\r\n-   # Logic for queries about the product with most questions++++++++\r\n-    if 'most' in lemmatized_tokens and 'question' in lemmatized_tokens or 'most' in user_input and 'question' in user_input:\r\n-        return product_with_most_questions(df)\r\n-\r\n-    # Logic for queries about the best selling brand\r\n-    if 'best' in lemmatized_tokens and 'selling' in lemmatized_tokens and 'brand' in lemmatized_tokens or 'best' in user_input and 'selling' in user_input and 'brand' in user_input:\r\n-        return brand_of_best_selling(df)\r\n-\r\n-    # Logic for queries about the brand of the highest price mobile\r\n-    if 'highest' in lemmatized_tokens and 'price' in lemmatized_tokens and 'brand' in lemmatized_tokens or  'highest' in user_input and 'price' in user_input and 'brand' in user_input:\r\n-        return brand_of_highest_price_mobile(df)\r\n-\r\n-    # Logic for queries about the brand of the lowest price mobile\r\n-    if 'lowest' in lemmatized_tokens and 'price' in lemmatized_tokens and 'brand' in lemmatized_tokens or  'lowest' in user_input and 'price' in user_input and 'brand' in user_input:\r\n-        return brand_of_lowest_price_mobile(df)\r\n-    else:\r\n-        return get_bot_response(user_input)\r\n-\r\n-\r\n-@app.route('/')\r\n-def index():\r\n-    return render_template('chat.html')\r\n-\r\n-@app.route('/process', methods=['POST'])\r\n-def process():\r\n-    user_input = request.form['userInput']\r\n-    response = analyze_input(user_input, df)  # Use the analyze_input function from your script\r\n-    return jsonify({'response': response})\r\n-\r\n-if __name__ == '__main__':\r\n-    app.run(debug=True)\r\n"
                },
                {
                    "date": 1701866297291,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -234,9 +234,9 @@\n \r\n \r\n @app.route('/')\r\n def index():\r\n-    return 'Hello, World'\r\n+    return render_template('chat.html')\r\n \r\n @app.route('/hello')\r\n def hello():\r\n     return 'Hello, World'\r\n"
                },
                {
                    "date": 1701866383538,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -238,9 +238,9 @@\n     return render_template('chat.html')\r\n \r\n @app.route('/hello')\r\n def hello():\r\n-    return 'Hello, World'\r\n+    return 'aaa, World'\r\n \r\n @app.route('/process', methods=['POST'])\r\n def process():\r\n     user_input = request.form['userInput']\r\n"
                },
                {
                    "date": 1701866392052,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -238,9 +238,9 @@\n     return render_template('chat.html')\r\n \r\n @app.route('/hello')\r\n def hello():\r\n-    return 'aaa, World'\r\n+    return 'Hello, World'\r\n \r\n @app.route('/process', methods=['POST'])\r\n def process():\r\n     user_input = request.form['userInput']\r\n"
                },
                {
                    "date": 1701866409796,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -243,9 +243,9 @@\n \r\n @app.route('/process', methods=['POST'])\r\n def process():\r\n     user_input = request.form['userInput']\r\n-    response = analyze_input(user_input, df)  # Use the analyze_input function from your script\r\n+    response = analyze_input(user_input, df)\r\n     return jsonify({'response': response})\r\n \r\n if __name__ == '__main__':\r\n     app.run(debug=True)\r\n"
                },
                {
                    "date": 1701866506763,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,11 @@\n from nltk.corpus import stopwords\r\n from nltk.stem import PorterStemmer\r\n from nltk.stem import WordNetLemmatizer\r\n \r\n+nltk.download('wordnet')\r\n+\r\n+\r\n # Initialize Flask app\r\n app = Flask(__name__)\r\n \r\n # Load your DataFrame here\r\n"
                },
                {
                    "date": 1701866606474,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,10 +6,10 @@\n from nltk.stem import PorterStemmer\r\n from nltk.stem import WordNetLemmatizer\r\n \r\n nltk.download('wordnet')\r\n+nltk.download('averaged_perceptron_tagger')\r\n \r\n-\r\n # Initialize Flask app\r\n app = Flask(__name__)\r\n \r\n # Load your DataFrame here\r\n"
                },
                {
                    "date": 1701867058137,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -239,11 +239,8 @@\n @app.route('/')\r\n def index():\r\n     return render_template('chat.html')\r\n \r\n-@app.route('/hello')\r\n-def hello():\r\n-    return 'Hello, World'\r\n \r\n @app.route('/process', methods=['POST'])\r\n def process():\r\n     user_input = request.form['userInput']\r\n"
                },
                {
                    "date": 1701868269138,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,251 @@\n+from flask import Flask, render_template, request, jsonify\r\n+import pandas as pd\r\n+import nltk\r\n+from nltk.tokenize import word_tokenize\r\n+from nltk.corpus import stopwords\r\n+from nltk.stem import PorterStemmer\r\n+from nltk.stem import WordNetLemmatizer\r\n+\r\n+nltk.download('wordnet')\r\n+nltk.download('averaged_perceptron_tagger')\r\n+\r\n+# Initialize Flask app\r\n+app = Flask(__name__)\r\n+\r\n+# Load your DataFrame here\r\n+# Example: df = pd.read_csv(\"your_data_file.csv\")\r\n+df = pd.read_csv('SET_DATA.csv')  # Replace with your actual data file\r\n+products = df\r\n+\r\n+# Initialize NLTK tools (Ensure you have downloaded the necessary NLTK datasets)\r\n+stop_words = set(stopwords.words('english'))\r\n+porter = PorterStemmer()\r\n+lemmatizer = WordNetLemmatizer()\r\n+# Function \r\n+# Function to find the product with the highest price\r\n+def product_with_highest_price(df):\r\n+    highest_price = df['Price'].max()\r\n+    highest_price_product = df[df['Price'] == highest_price]['Product Title'].values[0]\r\n+    return highest_price_product,highest_price\r\n+\r\n+# Function to find the product with the lowest price\r\n+def product_with_lowest_price(df):\r\n+    lowest_price = df['Price'].min()\r\n+    lowest_price_product = df[df['Price'] == lowest_price]['Product Title'].values[0]\r\n+    return lowest_price_product,lowest_price\r\n+\r\n+# Function to calculate the average price of products\r\n+def average_product_price(df):\r\n+    average_price = df['Price'].mean()\r\n+    return average_price\r\n+\r\n+# Function to find the product with the lowest rating\r\n+def product_with_lowest_rating(df):\r\n+    lowest_Rating = df['Rating'].min()\r\n+    lowest_Rating_product = df[df['Rating'] == lowest_Rating]['Product Title'].values[0]\r\n+    return lowest_Rating_product,lowest_Rating\r\n+\r\n+# Function to find the product with the highest rating\r\n+def product_with_highest_rating(df):\r\n+    highest_Rating = df['Rating'].max()\r\n+    highest_Rating_product = df[df['Rating'] == highest_Rating]['Product Title'].values[0]\r\n+    return highest_Rating_product,highest_Rating\r\n+\r\n+\r\n+\r\n+def best_phones_above_price(df, min_price):\r\n+    high_priced_phones = df[df['Price'] >= min_price]\r\n+    highest_rated_phones = high_priced_phones[high_priced_phones['Rating'] == high_priced_phones['Rating'].max()]\r\n+    recommended_phones = highest_rated_phones[['Product Title', 'Price']].copy()\r\n+    return recommended_phones\r\n+\r\n+def best_phones_under_price(df, max_price):\r\n+    affordable_phones = df[df['Price'] <= max_price]\r\n+    highest_rated_phones = affordable_phones[affordable_phones['Rating'] == affordable_phones['Rating'].max()]\r\n+    recommended_phones = highest_rated_phones[['Product Title', 'Price']].copy()\r\n+    return recommended_phones\r\n+ \r\n+\r\n+def products_with_free_shipping(df):\r\n+    free_shipping_df = df[df['Free Shipping Status'] == True]\r\n+    free_shipping_products = free_shipping_df['Product Title'].tolist()\r\n+    return free_shipping_products\r\n+\r\n+def products_in_daraz_mall(df):\r\n+    daraz_mall_df = df[df['Daraz Mall Status'] == True]\r\n+    daraz_mall_products = daraz_mall_df['Product Title'].tolist()\r\n+    return daraz_mall_products\r\n+\r\n+def sellers_with_best_rating(df):\r\n+    best_seller_rating = df['Seller Rating'].max()\r\n+    best_sellers = df[df['Seller Rating'] == best_seller_rating]['Product Title'].tolist()\r\n+    return best_sellers\r\n+\r\n+def sellers_who_ship_on_time(df):\r\n+    on_time_shippers = df[df['Ship on Time Score'] >= 90]  # Assuming the score is out of 100\r\n+    on_time_shipping_products = on_time_shippers['Product Title'].tolist()\r\n+    return on_time_shipping_products\r\n+\r\n+def get_product_specifications(df, product_title):\r\n+    product_specs = df[df['Product Title'].str.contains(product_title, case=False)]\r\n+    if not product_specs.empty:\r\n+        return product_specs.iloc[0]['Specifications']\r\n+    else:\r\n+        return \"Product not found.\"\r\n+\r\n+def find_phone_with_feature(df, feature):\r\n+    phones_with_feature = df[df['Specifications'].str.contains(feature, case=False)]\r\n+    products = phones_with_feature['Product Title'].tolist()\r\n+    return products\r\n+# +++++++++++++++++++++++++++++\r\n+\r\n+def product_with_most_questions(df):\r\n+    most_questions = df['No.of Questions'].max()\r\n+    most_questions_product = df[df['No.of Questions'] == most_questions]['Product Title'].values[0]\r\n+    return most_questions_product, most_questions\r\n+\r\n+def brand_of_best_selling(df):\r\n+    # Filter the products with the highest price first\r\n+    highest_price = df['Price'].max()\r\n+    highest_price_products = df[df['Price'] == highest_price]\r\n+    highest_rated = highest_price_products['Rating'].max()\r\n+    best_selling_product = highest_price_products[highest_price_products['Rating'] == highest_rated]\r\n+    best_selling_brand = best_selling_product['Brand'].values[0]\r\n+    return best_selling_brand, (highest_price, highest_rated)\r\n+\r\n+def brand_of_highest_price_mobile(df):\r\n+    highest_price = df['Price'].max()\r\n+    highest_price_brand = df[df['Price'] == highest_price]['Brand'].values[0]\r\n+    return highest_price_brand, highest_price\r\n+\r\n+def brand_of_lowest_price_mobile(df):\r\n+    lowest_price = df['Price'].min()\r\n+    lowest_price_brand = df[df['Price'] == lowest_price]['Brand'].values[0]\r\n+    return lowest_price_brand, lowest_price\r\n+\r\n+##\r\n+# Sample data in the form of a DataFrame with product information\r\n+# Replace this with the actual DataFrame you are using\r\n+\r\n+# Define your functions here (e.g., product_with_highest_price, product_with_lowest_price, etc.)\r\n+\r\n+bot_responses = {\r\n+    \"hi\": [\"Hi there!\", \"Hello!\"],\r\n+    \"hello\": [\"Hi there!\", \"Hello!\"],\r\n+    \"how are you\": [\"I'm good, thanks for asking.\", \"I'm doing well, thank you!\"],\r\n+    \"what's up\": [\"Not much, just here to help.\", \"I'm here to assist you!\"],\r\n+    \"goodbye\": [\"Goodbye!\", \"See you later!\", \"Bye!\"],\r\n+    \"thanks\": [\"myPleasure!\", \":}\", \":} :}\"],\r\n+}\r\n+\r\n+# Function to generate a random bot response\r\n+def get_bot_response(user_input):\r\n+    if user_input.lower() in bot_responses:\r\n+        return random.choice(bot_responses[user_input.lower()])\r\n+    else:\r\n+        return \"Sorry, I don't understand that.\"\r\n+\r\n+# Updated analyze_input function\r\n+def analyze_input(user_input, df):\r\n+    tokens = word_tokenize(user_input.lower())\r\n+    filtered_tokens = [word for word in tokens if word not in stop_words]\r\n+    stemmed_tokens = [porter.stem(word) for word in filtered_tokens]\r\n+    lemmatized_tokens = [lemmatizer.lemmatize(word) for word in stemmed_tokens]\r\n+    pos_tags = nltk.pos_tag(lemmatized_tokens)\r\n+    matching_columns = {token: column for token in lemmatized_tokens for column in df.columns if token in column.lower()}\r\n+\r\n+\r\n+#     # Example for 'price' related queries\r\n+ # Logic for 'price' related queries\r\n+    if 'price' in matching_columns or 'price' in user_input:\r\n+        if 'max' in lemmatized_tokens or 'highest' in lemmatized_tokens or 'max' in user_input or 'highest' in user_input:\r\n+            return product_with_highest_price(df)\r\n+        elif 'min' in lemmatized_tokens or 'lowest' in lemmatized_tokens or 'minimum' in user_input or 'lowest' in user_input:\r\n+            return product_with_lowest_price(df)\r\n+        elif 'averag' in lemmatized_tokens or 'average' in user_input:\r\n+            return average_product_price(df)\r\n+\r\n+    # Logic for 'rating' related queries\r\n+    if 'rating' in matching_columns or 'rating' in user_input:\r\n+        if 'max' in lemmatized_tokens or 'highest' in lemmatized_tokens or 'max' in user_input or 'highest' in user_input:\r\n+            return product_with_highest_rating(df)\r\n+        elif 'min' in lemmatized_tokens or 'lowest' in lemmatized_tokens or 'minimum' in user_input or 'lowest' in user_input:\r\n+            return product_with_lowest_rating(df)\r\n+\r\n+    # Logic for 'shipping' related queries\r\n+    if 'ship' in lemmatized_tokens or 'shipping' in matching_columns or 'ship' in user_input or 'shipping' in user_input:\r\n+        if 'free' in lemmatized_tokens or 'free' in user_input:\r\n+            return products_with_free_shipping(df)\r\n+        elif 'time' in lemmatized_tokens or 'time' in user_input:\r\n+            return sellers_who_ship_on_time(df)\r\n+\r\n+    # Logic for 'Daraz Mall' related queries\r\n+    if 'daraz' in lemmatized_tokens and 'mall' in lemmatized_tokens or 'daraz' in user_input and 'mall' in user_input:\r\n+        return products_in_daraz_mall(df)\r\n+\r\n+    # Logic for 'seller' related queries\r\n+    if 'seller' in matching_columns or 'seller' in user_input:\r\n+        if 'best' in lemmatized_tokens or 'top' in lemmatized_tokens or 'best' in user_input or 'top' in user_input:\r\n+            return sellers_with_best_rating(df)\r\n+\r\n+    # Logic for queries related to specific features or specifications\r\n+    if 'feature' in lemmatized_tokens or 'specification' in matching_columns or 'feature' in user_input or 'specification' in user_input:\r\n+        feature = \" \".join(tokens[tokens.index('with') + 1:]) if 'with' in tokens else \"\"\r\n+        return find_phone_with_feature(df, feature)\r\n+\r\n+    # Logic for finding best phones under a certain price\r\n+  # if 'best' in lemmatized_tokens and 'phone' in lemmatized_tokens or 'under' in lemmatized_tokens or 'best' in user_input and 'phone' in user_input or 'under' in user_input:\r\n+    if 'best' in lemmatized_tokens and 'phone' in lemmatized_tokens or 'under' in lemmatized_tokens or 'best' in user_input and 'phone' in user_input or 'under' in user_input:\r\n+        try:\r\n+            max_price = [int(t) for t in tokens if t.isdigit()]\r\n+            if max_price:\r\n+                return best_phones_under_price(df, max_price[0])  # Assuming you only need the first number found\r\n+            else:\r\n+                return \"Please provide a valid price limit.\"\r\n+        except ValueError:\r\n+            return \"Please provide a valid price limit.\"\r\n+\r\n+ ##0000000000000000000000\r\n+    if 'phone' in lemmatized_tokens and 'above' in lemmatized_tokens or 'greater' in lemmatized_tokens or 'phone' in user_input and 'above' in user_input or 'above' in user_input:\r\n+          try:\r\n+              max_price = [int(t) for t in tokens if t.isdigit()]\r\n+              if max_price:\r\n+                  return best_phones_above_price(df, max_price[0])  # Assuming you only need the first number found\r\n+              else:\r\n+                  return \"Please provide a valid price limit.\"\r\n+          except ValueError:\r\n+              return \"Please provide a valid price limit.\"\r\n+\r\n+\r\n+   # Logic for queries about the product with most questions++++++++\r\n+    if 'most' in lemmatized_tokens and 'question' in lemmatized_tokens or 'most' in user_input and 'question' in user_input:\r\n+        return product_with_most_questions(df)\r\n+\r\n+    # Logic for queries about the best selling brand\r\n+    if 'best' in lemmatized_tokens and 'selling' in lemmatized_tokens and 'brand' in lemmatized_tokens or 'best' in user_input and 'selling' in user_input and 'brand' in user_input:\r\n+        return brand_of_best_selling(df)\r\n+\r\n+    # Logic for queries about the brand of the highest price mobile\r\n+    if 'highest' in lemmatized_tokens and 'price' in lemmatized_tokens and 'brand' in lemmatized_tokens or  'highest' in user_input and 'price' in user_input and 'brand' in user_input:\r\n+        return brand_of_highest_price_mobile(df)\r\n+\r\n+    # Logic for queries about the brand of the lowest price mobile\r\n+    if 'lowest' in lemmatized_tokens and 'price' in lemmatized_tokens and 'brand' in lemmatized_tokens or  'lowest' in user_input and 'price' in user_input and 'brand' in user_input:\r\n+        return brand_of_lowest_price_mobile(df)\r\n+    else:\r\n+        return get_bot_response(user_input)\r\n+\r\n+\r\n+@app.route('/')\r\n+def index():\r\n+    return render_template('chat.html')\r\n+\r\n+\r\n+@app.route('/process', methods=['POST'])\r\n+def process():\r\n+    user_input = request.form['userInput']\r\n+    response = analyze_input(user_input, df)\r\n+    return jsonify({'response': response})\r\n+\r\n+if __name__ == '__main__':\r\n+    app.run(debug=True)\r\n"
                }
            ],
            "date": 1701866007123,
            "name": "Commit-0",
            "content": "from flask import Flask, render_template, request, jsonify\r\nimport pandas as pd\r\nimport nltk\r\nfrom nltk.tokenize import word_tokenize\r\nfrom nltk.corpus import stopwords\r\nfrom nltk.stem import PorterStemmer\r\nfrom nltk.stem import WordNetLemmatizer\r\n\r\n# Initialize Flask app\r\napp = Flask(__name__)\r\n\r\n# Load your DataFrame here\r\n# Example: df = pd.read_csv(\"your_data_file.csv\")\r\ndf = pd.read_csv('SET_DATA.csv')  # Replace with your actual data file\r\nproducts = df\r\n\r\n# Initialize NLTK tools (Ensure you have downloaded the necessary NLTK datasets)\r\nstop_words = set(stopwords.words('english'))\r\nporter = PorterStemmer()\r\nlemmatizer = WordNetLemmatizer()\r\n# Function \r\n# Function to find the product with the highest price\r\ndef product_with_highest_price(df):\r\n    highest_price = df['Price'].max()\r\n    highest_price_product = df[df['Price'] == highest_price]['Product Title'].values[0]\r\n    return highest_price_product,highest_price\r\n\r\n# Function to find the product with the lowest price\r\ndef product_with_lowest_price(df):\r\n    lowest_price = df['Price'].min()\r\n    lowest_price_product = df[df['Price'] == lowest_price]['Product Title'].values[0]\r\n    return lowest_price_product,lowest_price\r\n\r\n# Function to calculate the average price of products\r\ndef average_product_price(df):\r\n    average_price = df['Price'].mean()\r\n    return average_price\r\n\r\n# Function to find the product with the lowest rating\r\ndef product_with_lowest_rating(df):\r\n    lowest_Rating = df['Rating'].min()\r\n    lowest_Rating_product = df[df['Rating'] == lowest_Rating]['Product Title'].values[0]\r\n    return lowest_Rating_product,lowest_Rating\r\n\r\n# Function to find the product with the highest rating\r\ndef product_with_highest_rating(df):\r\n    highest_Rating = df['Rating'].max()\r\n    highest_Rating_product = df[df['Rating'] == highest_Rating]['Product Title'].values[0]\r\n    return highest_Rating_product,highest_Rating\r\n\r\n\r\n\r\ndef best_phones_above_price(df, min_price):\r\n    high_priced_phones = df[df['Price'] >= min_price]\r\n    highest_rated_phones = high_priced_phones[high_priced_phones['Rating'] == high_priced_phones['Rating'].max()]\r\n    recommended_phones = highest_rated_phones[['Product Title', 'Price']].copy()\r\n    return recommended_phones\r\n\r\ndef best_phones_under_price(df, max_price):\r\n    affordable_phones = df[df['Price'] <= max_price]\r\n    highest_rated_phones = affordable_phones[affordable_phones['Rating'] == affordable_phones['Rating'].max()]\r\n    recommended_phones = highest_rated_phones[['Product Title', 'Price']].copy()\r\n    return recommended_phones\r\n \r\n\r\ndef products_with_free_shipping(df):\r\n    free_shipping_df = df[df['Free Shipping Status'] == True]\r\n    free_shipping_products = free_shipping_df['Product Title'].tolist()\r\n    return free_shipping_products\r\n\r\ndef products_in_daraz_mall(df):\r\n    daraz_mall_df = df[df['Daraz Mall Status'] == True]\r\n    daraz_mall_products = daraz_mall_df['Product Title'].tolist()\r\n    return daraz_mall_products\r\n\r\ndef sellers_with_best_rating(df):\r\n    best_seller_rating = df['Seller Rating'].max()\r\n    best_sellers = df[df['Seller Rating'] == best_seller_rating]['Product Title'].tolist()\r\n    return best_sellers\r\n\r\ndef sellers_who_ship_on_time(df):\r\n    on_time_shippers = df[df['Ship on Time Score'] >= 90]  # Assuming the score is out of 100\r\n    on_time_shipping_products = on_time_shippers['Product Title'].tolist()\r\n    return on_time_shipping_products\r\n\r\ndef get_product_specifications(df, product_title):\r\n    product_specs = df[df['Product Title'].str.contains(product_title, case=False)]\r\n    if not product_specs.empty:\r\n        return product_specs.iloc[0]['Specifications']\r\n    else:\r\n        return \"Product not found.\"\r\n\r\ndef find_phone_with_feature(df, feature):\r\n    phones_with_feature = df[df['Specifications'].str.contains(feature, case=False)]\r\n    products = phones_with_feature['Product Title'].tolist()\r\n    return products\r\n# +++++++++++++++++++++++++++++\r\n\r\ndef product_with_most_questions(df):\r\n    most_questions = df['No.of Questions'].max()\r\n    most_questions_product = df[df['No.of Questions'] == most_questions]['Product Title'].values[0]\r\n    return most_questions_product, most_questions\r\n\r\ndef brand_of_best_selling(df):\r\n    # Filter the products with the highest price first\r\n    highest_price = df['Price'].max()\r\n    highest_price_products = df[df['Price'] == highest_price]\r\n    highest_rated = highest_price_products['Rating'].max()\r\n    best_selling_product = highest_price_products[highest_price_products['Rating'] == highest_rated]\r\n    best_selling_brand = best_selling_product['Brand'].values[0]\r\n    return best_selling_brand, (highest_price, highest_rated)\r\n\r\ndef brand_of_highest_price_mobile(df):\r\n    highest_price = df['Price'].max()\r\n    highest_price_brand = df[df['Price'] == highest_price]['Brand'].values[0]\r\n    return highest_price_brand, highest_price\r\n\r\ndef brand_of_lowest_price_mobile(df):\r\n    lowest_price = df['Price'].min()\r\n    lowest_price_brand = df[df['Price'] == lowest_price]['Brand'].values[0]\r\n    return lowest_price_brand, lowest_price\r\n\r\n##\r\n# Sample data in the form of a DataFrame with product information\r\n# Replace this with the actual DataFrame you are using\r\n\r\n# Define your functions here (e.g., product_with_highest_price, product_with_lowest_price, etc.)\r\n\r\nbot_responses = {\r\n    \"hi\": [\"Hi there!\", \"Hello!\"],\r\n    \"hello\": [\"Hi there!\", \"Hello!\"],\r\n    \"how are you\": [\"I'm good, thanks for asking.\", \"I'm doing well, thank you!\"],\r\n    \"what's up\": [\"Not much, just here to help.\", \"I'm here to assist you!\"],\r\n    \"goodbye\": [\"Goodbye!\", \"See you later!\", \"Bye!\"],\r\n    \"thanks\": [\"myPleasure!\", \":}\", \":} :}\"],\r\n}\r\n\r\n# Function to generate a random bot response\r\ndef get_bot_response(user_input):\r\n    if user_input.lower() in bot_responses:\r\n        return random.choice(bot_responses[user_input.lower()])\r\n    else:\r\n        return \"Sorry, I don't understand that.\"\r\n\r\n# Updated analyze_input function\r\ndef analyze_input(user_input, df):\r\n    tokens = word_tokenize(user_input.lower())\r\n    filtered_tokens = [word for word in tokens if word not in stop_words]\r\n    stemmed_tokens = [porter.stem(word) for word in filtered_tokens]\r\n    lemmatized_tokens = [lemmatizer.lemmatize(word) for word in stemmed_tokens]\r\n    pos_tags = nltk.pos_tag(lemmatized_tokens)\r\n    matching_columns = {token: column for token in lemmatized_tokens for column in df.columns if token in column.lower()}\r\n\r\n\r\n#     # Example for 'price' related queries\r\n # Logic for 'price' related queries\r\n    if 'price' in matching_columns or 'price' in user_input:\r\n        if 'max' in lemmatized_tokens or 'highest' in lemmatized_tokens or 'max' in user_input or 'highest' in user_input:\r\n            return product_with_highest_price(df)\r\n        elif 'min' in lemmatized_tokens or 'lowest' in lemmatized_tokens or 'minimum' in user_input or 'lowest' in user_input:\r\n            return product_with_lowest_price(df)\r\n        elif 'averag' in lemmatized_tokens or 'average' in user_input:\r\n            return average_product_price(df)\r\n\r\n    # Logic for 'rating' related queries\r\n    if 'rating' in matching_columns or 'rating' in user_input:\r\n        if 'max' in lemmatized_tokens or 'highest' in lemmatized_tokens or 'max' in user_input or 'highest' in user_input:\r\n            return product_with_highest_rating(df)\r\n        elif 'min' in lemmatized_tokens or 'lowest' in lemmatized_tokens or 'minimum' in user_input or 'lowest' in user_input:\r\n            return product_with_lowest_rating(df)\r\n\r\n    # Logic for 'shipping' related queries\r\n    if 'ship' in lemmatized_tokens or 'shipping' in matching_columns or 'ship' in user_input or 'shipping' in user_input:\r\n        if 'free' in lemmatized_tokens or 'free' in user_input:\r\n            return products_with_free_shipping(df)\r\n        elif 'time' in lemmatized_tokens or 'time' in user_input:\r\n            return sellers_who_ship_on_time(df)\r\n\r\n    # Logic for 'Daraz Mall' related queries\r\n    if 'daraz' in lemmatized_tokens and 'mall' in lemmatized_tokens or 'daraz' in user_input and 'mall' in user_input:\r\n        return products_in_daraz_mall(df)\r\n\r\n    # Logic for 'seller' related queries\r\n    if 'seller' in matching_columns or 'seller' in user_input:\r\n        if 'best' in lemmatized_tokens or 'top' in lemmatized_tokens or 'best' in user_input or 'top' in user_input:\r\n            return sellers_with_best_rating(df)\r\n\r\n    # Logic for queries related to specific features or specifications\r\n    if 'feature' in lemmatized_tokens or 'specification' in matching_columns or 'feature' in user_input or 'specification' in user_input:\r\n        feature = \" \".join(tokens[tokens.index('with') + 1:]) if 'with' in tokens else \"\"\r\n        return find_phone_with_feature(df, feature)\r\n\r\n    # Logic for finding best phones under a certain price\r\n  # if 'best' in lemmatized_tokens and 'phone' in lemmatized_tokens or 'under' in lemmatized_tokens or 'best' in user_input and 'phone' in user_input or 'under' in user_input:\r\n    if 'best' in lemmatized_tokens and 'phone' in lemmatized_tokens or 'under' in lemmatized_tokens or 'best' in user_input and 'phone' in user_input or 'under' in user_input:\r\n        try:\r\n            max_price = [int(t) for t in tokens if t.isdigit()]\r\n            if max_price:\r\n                return best_phones_under_price(df, max_price[0])  # Assuming you only need the first number found\r\n            else:\r\n                return \"Please provide a valid price limit.\"\r\n        except ValueError:\r\n            return \"Please provide a valid price limit.\"\r\n\r\n ##0000000000000000000000\r\n    if 'phone' in lemmatized_tokens and 'above' in lemmatized_tokens or 'greater' in lemmatized_tokens or 'phone' in user_input and 'above' in user_input or 'above' in user_input:\r\n          try:\r\n              max_price = [int(t) for t in tokens if t.isdigit()]\r\n              if max_price:\r\n                  return best_phones_above_price(df, max_price[0])  # Assuming you only need the first number found\r\n              else:\r\n                  return \"Please provide a valid price limit.\"\r\n          except ValueError:\r\n              return \"Please provide a valid price limit.\"\r\n\r\n\r\n   # Logic for queries about the product with most questions++++++++\r\n    if 'most' in lemmatized_tokens and 'question' in lemmatized_tokens or 'most' in user_input and 'question' in user_input:\r\n        return product_with_most_questions(df)\r\n\r\n    # Logic for queries about the best selling brand\r\n    if 'best' in lemmatized_tokens and 'selling' in lemmatized_tokens and 'brand' in lemmatized_tokens or 'best' in user_input and 'selling' in user_input and 'brand' in user_input:\r\n        return brand_of_best_selling(df)\r\n\r\n    # Logic for queries about the brand of the highest price mobile\r\n    if 'highest' in lemmatized_tokens and 'price' in lemmatized_tokens and 'brand' in lemmatized_tokens or  'highest' in user_input and 'price' in user_input and 'brand' in user_input:\r\n        return brand_of_highest_price_mobile(df)\r\n\r\n    # Logic for queries about the brand of the lowest price mobile\r\n    if 'lowest' in lemmatized_tokens and 'price' in lemmatized_tokens and 'brand' in lemmatized_tokens or  'lowest' in user_input and 'price' in user_input and 'brand' in user_input:\r\n        return brand_of_lowest_price_mobile(df)\r\n    else:\r\n        return get_bot_response(user_input)\r\n\r\n\r\n@app.route('/')\r\ndef index():\r\n    return render_template('chat.html')\r\n\r\n@app.route('/process')\r\ndef process():\r\n    user_input = request.form['userInput']\r\n    response = analyze_input(user_input, df)  # Use the analyze_input function from your script\r\n    return jsonify({'response': response})\r\n\r\nif __name__ == '__main__':\r\n    app.run(debug=True)\r\n"
        }
    ]
}